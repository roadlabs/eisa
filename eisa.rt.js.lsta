::annot-js eisa.rt.js
:include doc/annot.lsta
:title Eisa.rt.js

Eisa 运行时, by Belleve Invis

:section （很无力的）命名约定
	* 和 Eisa 运行时密切相关的部分，均有以 `EISA_` 开首的全局变量。考虑到 Eisa 生成代码，仍然使用全局变量。
	
	  TBD: 改用 commonJS 相似方式，在动态生成代码中显式导入。
	* 仅用于生成代码，几乎不可能被用户代码调用者，全大写表示之。
	* 可能被第三方调用者，包含普通命名格式。

:@ module-system-init
	初始化 Essentia，设置起始目录为 `lib`

:a Nai
	Nai 是 Eisa 的基本对象之一，很多场合——包括变量名检测——都依赖于之。

	Nai 对象的所有属性都是 undefined，甚至 `valueOf` 亦然。本来我想连 `toString` 也设置成 undefined 的，考虑到调试，所以注释掉了这一行。

:i derive
	最重要的原语之一（也是唯一没有 `EISA_` 前缀的原语）。这个原语创建某对象的直接派生，而不用使用构造器。

:@ OWNS
	`hasOwnProperty` 的封装。

:@ SLICE
	`Array.prototype.slice` 的封装，可以用于 Arguments 对象。

:@ UNIQ
	用于数组去重的原语，主要用于名称参数相关代码的生成。

:@ NamedArguments
	描述命名参数的对象类型。其原型属于 Nai。
	
	* `fetch` 方法会检测 某属性是否本征，如果是，返回之；否则得到 undefined。
	* `enumerate` 方法会枚举某命名参数组的所有项，并执行对应的方法。
	* `each` 是 `enumerate` 的别名

:@ EISA_CNARG
	这个方法判断某个对象是否是 NamedArguments。如果是，返回之；否则返回一个空的 NamedArguments 对象。

:@ M_TOP
	默认函数调用时的 `this` 指针。

:@ AUX-METHODS
	这些辅助方法在 Eisa 生成的代码中有作用。

:@ OBSTRUCTIVE_SCHEMATA_M
	阻塞原语范式的原型，包含一个 `return` 方法。
	
:@ Exceptions
	`EISA_THROW` 和 `EISA_TRY` 原语用来处理异常。考虑到 Eisa 阻塞原语流程控制的特殊性，Eisa 生成的代码中，不使用 `try`/`throw` 语句。

:@ proto-exts
	这里扩展的方法用于 Eisa 运行时，和语法配合。

:@ ES5
	一些 ECMAScript v5 的方法，进行 Back-porting：

	* `Array.prototype.map`
	* `Array.prototype.some`
	* `Array.prototype.reduce`
	* `Array.prototype.reduceRight`
	* `Array.prototype.every`
	* `Array.prototype.filter`
	* `Array.prototype.forEach`

:i Rule
	Rule 可看做二元组，包含 `left` 和 `right` 属性。

	* `reverse` 方法：生成新的 Rule，对调其 `left` 和 `right`
	* `each` 方法：视作范围，进行迭代

:@ eisa-master
	Eisa 的主控命名空间。

:@ eisa-module-helpers
	这里接合 Essentia，使用 `ESSENTIA_module` 的 `provide` 导入模块并分析导入接口。
